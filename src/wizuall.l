%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "codegen.h"
#include "wizuall.tab.h" // Generated by Bison

// Forward declare or define helper here
char* save_string(const char* str) {
    char* new_str = strdup(str);
    if (!new_str) {
        perror("strdup failed in lexer");
        exit(EXIT_FAILURE);
    }
    return new_str;
}
// Helper to save string literal content (strips quotes, basic escapes could be added)
char* save_string_strip_quotes(const char* raw_str) {
    size_t len = strlen(raw_str);
    if (len < 2) return strdup(""); // Should not happen if regex is correct
    char* content = malloc(len - 1); // len - 2 for content + 1 for null terminator
    if (!content) { perror("malloc failed in save_string_strip_quotes"); exit(EXIT_FAILURE); }
    strncpy(content, raw_str + 1, len - 2);
    content[len - 2] = '\0';
    // Add escape sequence handling here if needed (e.g., replace \" with ")
    return content;
}


// Track line numbers
extern int yylineno;

%}

%option noyywrap nounput noinput yylineno

/* Regex Definitions */
DIGIT       [0-9]
ID          [a-zA-Z_][a-zA-Z0-9_]*
STRING      \"([^"\\]|\\.)*\" 
NUMBER      {DIGIT}+(\.{DIGIT}+)?([eE][-+]?{DIGIT}+)?

/* States for native code blocks */
%x NATIVE

%%

<INITIAL>{
"if"        { return T_IF; }
"else"      { return T_ELSE; }
"while"     { return T_WHILE; }

"plot_histogram"    { return T_PLOT_HISTOGRAM; }
"plot_scatter"      { return T_PLOT_SCATTER; }
"plot_xy"           { return T_PLOT_XY; }
"calculate_average" { yylval.sval = save_string(yytext); return T_CALC_STAT; }
"calculate_max"     { yylval.sval = save_string(yytext); return T_CALC_STAT; }
"calculate_min"     { yylval.sval = save_string(yytext); return T_CALC_STAT; }
"calculate_sum"     { yylval.sval = save_string(yytext); return T_CALC_STAT; }
"slice_vector"      { return T_SLICE_VECTOR; }
"reverse_vector"    { return T_REVERSE_VECTOR; }
"find_clusters"     { return T_FIND_CLUSTERS; }
"get_column"        { return T_GET_COLUMN; }
"load_csv"          { return T_LOAD_CSV; }
{ID}        { yylval.sval = save_string(yytext); return T_IDENTIFIER; }
{NUMBER}    { yylval.dval = atof(yytext); return T_NUMBER; }
{STRING}    { yylval.sval = save_string_strip_quotes(yytext); return T_STRING_LITERAL; }
";"         { return T_SEMICOLON; }
"="         { return T_ASSIGN; }
"+"         { return T_PLUS; }
"-"         { return T_MINUS; }
"*"         { return T_MULTIPLY; }
"/"         { return T_DIVIDE; }
"<"         { return T_LT; }      // Less Than
">"         { return T_GT; }      // Greater Than
"<="        { return T_LTE; }     // Less Than or Equal
">="        { return T_GTE; }     // Greater Than or Equal
"=="        { return T_EQ; }      // Equal
"!="        { return T_NEQ; }     // Not Equal
"("         { return T_LPAREN; }
")"         { return T_RPAREN; }
"{"         { return T_LBRACE; }
"}"         { return T_RBRACE; }
"["         { return T_LBRACKET; }
"]"         { return T_RBRACKET; }
","         { return T_COMMA; }

"*-*"       { yylval.sval = save_string(""); BEGIN(NATIVE); /* Start accumulating native code */}

[ \t]+      { /* Ignore whitespace */ }
\n          { /* Handled by yylineno option */ }
"//".*      { /* Ignore single-line comments */ }

.           { fprintf(stderr, "Lexer Error line %d: Unexpected character '%s'\n", yylineno, yytext); /* Error */ }

<<EOF>>     { return 0; /* End of input */ }

} /* End INITIAL state rules */


<NATIVE>{
"*-*"       { BEGIN(INITIAL); return T_NATIVE_CODE; /* End native block, return token */}

[^*\n]+     { char* old = yylval.sval;
              // Use realloc for potentially better efficiency? Or stick to malloc/strcpy/strcat
              char* temp = malloc(strlen(old) + strlen(yytext) + 1);
              if(!temp) {perror("malloc failed NATIVE"); exit(EXIT_FAILURE);}
              strcpy(temp, old);
              strcat(temp, yytext);
              free(old);
              yylval.sval = temp;
            }
"*"         { char* old = yylval.sval; /* Handle '*' that might be part of '*-*' */
              char* temp = malloc(strlen(old) + 2);
              if(!temp) {perror("malloc failed NATIVE *"); exit(EXIT_FAILURE);}
              strcpy(temp, old);
              strcat(temp, "*");
              free(old);
              yylval.sval = temp;
            }
\n          { char* old = yylval.sval; /* Keep newlines in native code */
              char* temp = malloc(strlen(old) + 2);
               if(!temp) {perror("malloc failed NATIVE nl"); exit(EXIT_FAILURE);}
              strcpy(temp, old);
              strcat(temp, "\n");
              free(old);
              yylval.sval = temp;
              yylineno++; // Increment lineno here since default rule doesn't run in this state
            }
<<EOF>>     { fprintf(stderr, "Lexer Error line %d: Unterminated native code block '*-*'\n", yylineno);
              BEGIN(INITIAL); /* Reset state */
              // Decide what to return on error. Maybe 0 or a specific error token?
              // Returning 0 might stop parsing prematurely. Let's signal error differently if Bison handles it.
              // For now, just resetting state and maybe returning 0 is okay.
              // Make sure yylval.sval is freed or valid if returning T_NATIVE_CODE
              free(yylval.sval); // Free the partially accumulated string
              yylval.sval = NULL; // Avoid double free
              return 0; // Stop processing
            }
} /* End NATIVE state rules */

%% // <--- SECOND %% separator is crucial

// User C code section below this line if needed
// (save_string moved to top section)

// No yywrap function needed due to %option noyywrap